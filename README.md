# NaturalScript

LLMを使うと自然言語でプログラミングができるが、プロンプトエンジニアリングには限界があるため、抽象化してフレームワークでプロンプトの生成をしたい。

## 目指すところ

* Markdownを記述することでLLMを扱うためのフレームワークを提供する
* Markdownのコードブロックで、プロンプトとロジックを指定できるようにする
* Markdownを使った文芸的プログラミング
* ロジックをTypeScriptで記述し、メタプロを駆使して、実際にLLMに埋め込むロジックに変換する
* 実際にどういう変換が有効か、実際に投げまくって検証できる仕組みを作る
* 試行錯誤をJSONに落とし込みたい

### モチベーション

プロンプトにプログラム的な仕組みを導入する試みがあるが、自然言語でそれを実現するのは、記述が高度になればなるほど面倒臭いのと、再現性に難があるので使い物にならない。

そもそもLLMの種類やバージョンが異なると、そのノウハウは使えなくなる可能性が極めて高い。

自然言語 + 形式言語というやり方で、記述が楽になったり、再現性を高めることが期待できるが、本当にそれで再現性が高まるとも限らない。

## 一番簡単な使い方

コードブロックでプロンプトを指定する。

````
```system
日本の経済低迷について教えてください。
```
````

### CLIとして使う

```sh
deno run --allow-net --allow-env --allow-read src/cli.ts examples/simple.md
```

## 変数

コードブロックで`:hoge`のようにコロンで始まる名前をつけた場合、変数として登録される。

````md
```:hoge
ほげ
```

```plaintext :fuga
ふが
```
````

これらは、それぞれ `hoge` と `fuga` という変数名で登録される。

変数は `{hoge}` `{fuga}` のような記法で展開が可能である。

````md
```system
{hoge}
{fuga}
```
````

## フロントマター

Markdownの先頭にフロントマターを記述できる。

````md
---
output: "result"
json:
  output: "base.json"
---

```system
日本の経済低迷について教えてください。
```
````

このようなMarkdownを実行した場合、LLMの実行結果が `base.json` の `result` という項目に出力される。

変数は Markdown の中で定義が可能だが、JSONファイルから読み込むことも可能である。

```json
{
  "hoge": "ほげ"
}
```

というような JSON ファイルが `base.json` という名前で存在する場合

````md
```system
{hoge}
```
````

の `{hoge}` は JSON ファイルから読み取った `ほげ` に展開される。

### デフォルト値

```yaml
json:
  output: "base.json"
  input: "base.json"
```

がデフォルト値として指定されている。